-------------------------------------------------
--                                             --
--         Parser generated by Coco/R          --
--                                             --
-- (assuming FileIO library will be available) --
-------------------------------------------------

with  RulesS;

package body RulesP is

   


   --
   -- Report semantic error errNo
   --
   procedure Semantic_Error (errNo: in     Integer)
   is
   begin
      if  errDist >= minErrDist  then
         RulesS.Error (errNo, RulesS.line, RulesS.col, RulesS.pos);
      end if;
      errDist := 0;
   end Semantic_Error;


   --
   -- Report syntax error errNo
   --
   procedure Syntax_Error (errNo: in     Integer)
   is
   begin
      if  errDist >= minErrDist  then
         RulesS.Error (errNo, RulesS.nextLine, RulesS.nextCol, RulesS.nextPos);
      end if;
      errDist := 0;
   end Syntax_Error;


   procedure Get
   is
      S: FileIO.String_Ptr;
   begin
      loop
         RulesS.Get (sym);
         if  sym <= maxT  then
            errDist := errDist + 1;
         else
            null;
         end if;
         exit when sym <= maxT;
      end loop;
   end Get;


   function Is_In
     (s: in     SymbolSet;
      x: in     CARDINAL)
     return Boolean
   is
   begin
      return  Sets.Is_In ((x mod setsize), s (x / setsize));
   end Is_In;

   procedure Is_In
     (s     : in out SymbolSet;
      x     : in     CARDINAL;
      Result:    out Boolean)
   is
   begin
      Result := Sets.Is_In ((x mod setsize), s (x / setsize));
   end Is_In;


   procedure Expect (n: in     CARDINAL)
   is
   begin
      if  sym = n  then
         Get;
      else
         Syntax_Error (n);
      end if;
   end Expect;


   procedure Expect_Weak
     (n     : CARDINAL;
      follow: CARDINAL)
   is
      Is_In_Result : Boolean;
   begin
      if  sym = n  then
         Get;
      else
         Syntax_Error (n);
   --       while  not Is_In (symSet (follow), sym)  loop
   --          Get;
   --       end loop;
         loop
            Is_In (symSet (follow), sym, Is_In_Result);
            exit when not Is_In_Result;
            Get;
         end loop;
      end if;
   end Expect_Weak;


   function Weak_Separator
     (n     : CARDINAL;
      syFol : CARDINAL;
      repFol: CARDINAL)
     return Boolean
   is
      use type Sets.BitSet;

      s           : SymbolSet;
      I           : CARDINAL;
      Is_In_Result: Boolean;
   begin
      if  sym = n  then
         Get;
         return TRUE;
      else
         Is_In (symSet (repFol), sym, Is_In_Result);
         if  Is_In_Result  then
            return FALSE;
         else
            I := 0;
            while  (I <= (maxT / setsize))  loop
               s (I) := symSet (0) (I) + symSet (syFol) (I) + symSet (repFol) (I);
               I := I + 1;
            end loop;
            Syntax_Error (n);
            loop
               Is_In (s, sym, Is_In_Result);
               exit when not Is_In_Result;
               Get;
            end loop;

            Is_In (symSet (syFol), sym, Is_In_Result);
            return Is_In_Result;
         end if;
      end if;
   end Weak_Separator;


   --
   -- Retrieves Lex as name of current token (capitalized if IGNORE case )
   --
   procedure Lex_Name (Lex:    out FileIO.String_Ptr)
   is
   begin
      RulesS.Get_Name (RulesS.pos, RulesS.len, Lex);
   end Lex_Name;


   --
   -- Retrieves Lex as exact spelling of current token
   --
   procedure Lex_String (Lex:    out FileIO.String_Ptr)
   is
   begin
      RulesS.Get_String (RulesS.pos, RulesS.len, Lex);
   end Lex_String;


   --
   -- Retrieves Lex as exact spelling of lookahead token
   --
   procedure Look_Ahead_Name (Lex:    out FileIO.String_Ptr)
   is
   begin
      RulesS.Get_Name (RulesS.nextPos, RulesS.nextLen, Lex);
   end Look_Ahead_Name;


   --
   -- Retrieves Lex as name of lookahead token (capitalized if IGNORE case )
   --
   procedure Look_Ahead_String (Lex:    out FileIO.String_Ptr)
   is
   begin
      RulesS.Get_String (RulesS.nextPos, RulesS.nextLen, Lex);
   end Look_Ahead_String;


   --
   -- Returns TRUE if no errors have been recorded while parsing
   --
   function Successful return Boolean
   is
   begin
      return RulesS.errors = 0;
   end Successful;


   procedure NumRange;
   procedure Boolean;
   procedure NumSet;
   procedure Literal;
   procedure RelOp;
   procedure Property;
   procedure Condition;
   procedure Action;
   procedure CondList;
   procedure State;
   procedure WC_State;
   procedure ActionList;
   procedure BranchChain;
   procedure Transition;
   procedure Rule;
   procedure Rules;

   procedure NumRange
   is
   begin -- NumRange
      Expect (2);
      if  (sym = 32)  then
         Get;
         Expect (2);
      end if;
   end NumRange;

   procedure Boolean
   is
   begin -- Boolean
      if  (sym = 27)  then
         Get;
      elsif  (sym = 28)  then
         Get;
      elsif  (sym = 29)  then
         Get;
      elsif  (sym = 30)  then
         Get;
      else
         Syntax_Error (34);
      end if;
   end Boolean;

   procedure NumSet
   is
   begin -- NumSet
      NumRange;
      while  (sym = 31)  loop
         Get;
         NumRange;
      end loop;
   end NumSet;

   procedure Literal
   is
   begin -- Literal
      if  (sym = 3)  then
         Get;
      elsif  (sym = 2)  then
         NumSet;
      elsif  (sym = 27) or else (sym = 28) or else (sym = 29) or else (sym = 30)  then
         Boolean;
      else
         Syntax_Error (35);
      end if;
   end Literal;

   procedure RelOp
   is
   begin -- RelOp
      if  (sym = 18)  then
         Get;
      elsif  (sym = 19)  then
         Get;
      elsif  (sym = 20)  then
         Get;
      elsif  (sym = 21)  then
         Get;
      elsif  (sym = 22)  then
         Get;
      else
         Syntax_Error (36);
      end if;
   end RelOp;

   procedure Property
   is
   begin -- Property
      if  (sym = 23)  then
         Get;
      elsif  (sym = 24)  then
         Get;
      elsif  (sym = 25)  then
         Get;
      elsif  (sym = 26)  then
         Get;
      else
         Syntax_Error (37);
      end if;
   end Property;

   procedure Condition
   is
   begin -- Condition
      Property;
      RelOp;
      Literal;
   end Condition;

   procedure Action
   is
   begin -- Action
      if  (sym = 13) or else (sym = 14)  then
         if  (sym = 13)  then
            Get;
         else
            Get;
         end if;
         Literal;
         if  (sym = 15)  then
            Get;
         elsif  (sym = 16)  then
            Get;
         else
            Syntax_Error (38);
         end if;
         Property;
      elsif  (sym = 17)  then
         Get;
         Property;
         Expect (15);
         Literal;
      else
         Syntax_Error (39);
      end if;
   end Action;

   procedure CondList
   is
   begin -- CondList
      Condition;
      while  (sym = 10)  loop
         Get;
         Condition;
      end loop;
   end CondList;

   procedure State
   is
   begin -- State
      if  (sym = 11)  then
         Get;
      elsif  (sym = 12)  then
         Get;
      else
         Syntax_Error (40);
      end if;
   end State;

   procedure WC_State
   is
   begin -- WC_State
      if  (sym = 11) or else (sym = 12)  then
         State;
      elsif  (sym = 6)  then
         Get;
      else
         Syntax_Error (41);
      end if;
   end WC_State;

   procedure ActionList
   is
   begin -- ActionList
      Action;
      while  (sym = 10)  loop
         Get;
         Action;
      end loop;
   end ActionList;

   procedure BranchChain
   is
   begin -- BranchChain
      Expect (7);
      CondList;
      Expect (8);
      ActionList;
      while  (sym = 9)  loop
         Get;
         CondList;
         Expect (8);
         ActionList;
      end loop;
   end BranchChain;

   procedure Transition
   is
   begin -- Transition
      WC_State;
      Expect (5);
      WC_State;
   end Transition;

   procedure Rule
   is
   begin -- Rule
      Transition;
      if  (sym = 7)  then
         BranchChain;
      elsif  (sym = 13) or else (sym = 14) or else (sym = 17)  then
         ActionList;
      else
         Syntax_Error (42);
      end if;
      Expect (4);
   end Rule;

   procedure Rules
   is
   begin -- Rules
      Rule;
      Expect (4);
      while  (sym = 6) or else (sym = 11) or else (sym = 12)  loop
         Rule;
         Expect (4);
      end loop;
   end Rules;




   procedure Parse
   is
   begin
      RulesS.Reset;
      Get;
      Rules;

   end Parse;


begin -- CRP
   errDist := minErrDist;

   symSet ( 0)(0) := Sets.BITSET'(0 => TRUE, others => FALSE);
   symSet ( 0)(1) := Sets.BITSET'(others => FALSE);
   symSet ( 0)(2) := Sets.BITSET'(others => FALSE);

end RulesP;





