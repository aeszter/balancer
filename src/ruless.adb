-------------------------------------------------
--                                             --
--       Scanner generated by Coco/R           --
--                                             --
-- (assuming FileIO library will be available) --
-------------------------------------------------


with FileIO;


package body RulesS is


   noSYMB  : constant := 33;  -- error token code
   -- not only for errors but also for not finished states of scanner analysis
   EOF     : constant Character := FileIO.EOF;
   EOL     : constant Character := FileIO.CR;
   CR      : constant Character := FileIO.CR;
   LF      : constant Character := FileIO.LF;
   BlkSize : constant := 16384;



   subtype  BufBlock       is String (1 .. (BlkSize));
   type     BufBlock_Ptr   is access BufBlock;

   type     Buffer         is array (Integer range 0 .. 31) of BufBlock_Ptr;
   type     StartTable     is array (Integer range 0 .. 255) of Integer;

   type     GetCH          is access function (pos: in     INT32) return Character;



   lastCh      : Character;
   ch          : Character;   -- current input character
   curLine     : Integer;     -- current input line (may be higher than line)
   lineStart   : INT32;       -- start position of current line
   apx         : INT32;       -- length of appendix (CONTEXT phrase)
   oldEols     : Integer;     -- number of EOLs in a comment

   bp          : INT32;       -- current position in buf
   bp0         : INT32;       -- position of current token

   LBlkSize    : INT32;       -- BlkSize
   inputLen    : INT32;       -- source file size

   buf         : Buffer;      -- source buffer for low-level access
   start       : StartTable;  -- start state for every character
   Current_Ch  : GetCH;



   function ORDL (n: in     INT32) return CARDINAL renames FileIO.ORDL;


   procedure Err
     (nr    : in     Integer;
      line  : in     Integer;
      col   : in     Integer;
      pos   : in     INT32)
   is
   begin
      errors := errors + 1;
   end Err;


   --
   -- Return global variable ch
   --
   procedure Next_Ch
   is
   begin
      lastCh := ch;
      bp := bp + 1;
      ch := Current_Ch (bp);
      if  (ch = EOL) or else ((ch = FileIO.LF) and then (lastCh /= EOL))  then
         curLine := curLine + 1;
         lineStart := bp;
      end if;
   end Next_Ch;


   function Comment return Boolean
   is
      level       : Integer;
      startLine   : Integer;
      oldLineStart: INT32;
   begin
      level        := 1;
      startLine    := curLine;
      oldLineStart := lineStart;
      if  (ch = '#')  then
         Next_Ch;
         loop
            if  (ch = Character'Val (10))  then
               level   := level - 1;
               oldEols := curLine - startLine;
               Next_Ch;
               if  level = 0  then
                  return TRUE;
               end if;
            elsif  ch = EOF  then
               return FALSE;
            else
               Next_Ch;
            end if;
         end loop;
      end if;
      
      return FALSE;
   end Comment;


   --
   -- Gets next symbol from source file
   --
   procedure Get (sym:    out CARDINAL)
   is

      state: CARDINAL;

      function Equal (S: in     String) return Boolean
      is
         I: CARDINAL;
         q: INT32;
      begin
         if  nextLen /= FileIO.SLENGTH (S)  then
            return FALSE;
         end if;

         I := S'First + 1;
         q := bp0 + 1;

         while  I <= nextLen  loop
            if  Current_Ch (q) /= S (I)  then
               return FALSE;
            end if;
            I := I + 1;
            q := q + 1;
         end loop;

         return TRUE;
      end Equal;

      procedure Check_Literal
      is
      begin
         case  Current_Ch (bp0)  is
         when 'P' =>
               if Equal ("PE") then
                  sym := 23; 
               end if;
            when 'a' =>
               if Equal ("add") then
                  sym := 13; 
               elsif Equal ("and") then
                  sym := 10; 
               end if;
            when 'c' =>
               if Equal ("cpu") then
                  sym := 11; 
               end if;
            when 'e' =>
               if Equal ("elsif") then
                  sym := 9; 
               end if;
            when 'f' =>
               if Equal ("false") then
                  sym := 30; 
               elsif Equal ("from") then
                  sym := 16; 
               end if;
            when 'g' =>
               if Equal ("gpu") then
                  sym := 12; 
               end if;
            when 'i' =>
               if Equal ("if") then
                  sym := 7; 
               end if;
            when 'o' =>
               if Equal ("off") then
                  sym := 28; 
               elsif Equal ("on") then
                  sym := 27; 
               end if;
            when 'r' =>
               if Equal ("remove") then
                  sym := 14; 
               elsif Equal ("reservation") then
                  sym := 26; 
               elsif Equal ("resources") then
                  sym := 25; 
               end if;
            when 's' =>
               if Equal ("set") then
                  sym := 17; 
               elsif Equal ("slots") then
                  sym := 24; 
               end if;
            when 't' =>
               if Equal ("then") then
                  sym := 8; 
               elsif Equal ("to") then
                  sym := 15; 
               elsif Equal ("true") then
                  sym := 29; 
               end if;
            when others =>
               null;
         end case;
      end Check_Literal;

   begin -- Get
      while  (ch = ' ') or else
            (((ch >= Character'Val (9)) and then (ch <= Character'Val (10))) or else
            (ch = Character'Val (13))) loop  Next_Ch;  end loop;
      if  ((ch = '#')) and then Comment  then
         Get (sym);
         return;
      end if;

      pos      := nextPos;   
      nextPos  := bp;
      col      := nextCol;   
      nextCol  := FileIO.INTL (bp - lineStart);
      line     := nextLine; 
      nextLine := curLine;
      len      := nextLen;   
      nextLen  := 0;
--       apx      := 0; 
      state    := start (Character'Pos (ch)); 
      bp0      := bp;

      loop
         Next_Ch; 
         nextLen := nextLen + 1;
         case  state  is
               when  1 =>
                  if  (((ch >= '0') and then (ch <= '9')) or else
                           ((ch >= 'A') and then (ch <= 'Z')) or else
                           (ch = '_') or else
                           ((ch >= 'a') and then (ch <= 'z')))  then
                     null; 
                  else
                     sym := 1; 
                     Check_Literal;
                     return;
                  end if;
               when  2 =>
                  if  (((ch >= '0') and then (ch <= '9')))  then
                     null; 
                  else
                     sym := 2; 
                     return;
                  end if;
               when  3 =>
                  if  ((ch = Character'Val (0)) or else
                           ((ch >= ' ') and then (ch <= '!')) or else
                           (ch >= '#'))  then
                     null; 
                  elsif  (ch = '"')  then
                     State := 4; 
                  else
                     sym := noSYMB;
                     return;
                  end if;
               when  4 =>
                     sym := 3; 
                     return;
               when  5 =>
                     sym := 4; 
                     return;
               when  6 =>
                  if  (ch = '>')  then
                     State := 7; 
                  else
                     sym := 32; 
                     return;
                  end if;
               when  7 =>
                     sym := 5; 
                     return;
               when  8 =>
                     sym := 6; 
                     return;
               when  9 =>
                     sym := 18; 
                     return;
               when 10 =>
                     sym := 19; 
                     return;
               when 11 =>
                     sym := 20; 
                     return;
               when 12 =>
                     sym := 21; 
                     return;
               when 13 =>
                     sym := 22; 
                     return;
               when 14 =>
                     sym := 31; 
                     return;
               when 15 =>
                  sym := 0; 
                  ch := Character'Val (0);
                  bp := bp - 1;
                  return;
            when others =>    -- Next_Ch already done
               sym := noSYMB;
               return;
         end case;
      end loop;
   end Get;


   --
   -- Retrieves exact The_String of max The_Length from The_Position in source file
   --
   procedure Get_String
     (The_Position   : in     INT32;
      The_Length     : in     CARDINAL;
      The_String     :    out FileIO.String_Ptr)
   is
   begin
      if  The_Length <= 0  then 
         The_String := null;
      else
         declare
            S : String (1..The_Length);
            P : INT32;         
         begin
            P := The_Position;
            for  I in S'Range  loop
               S (I) := Char_At (P); 
               P     := P + 1;
            end loop;
            The_String := new String'(S);
         end;
      end if;
   end Get_String;

   --
   -- Retrieves The_Name of symbol of The_Length at The_Position in source file
   --
   procedure Get_Name
     (The_Position   : in     INT32;
      The_Length     : in     CARDINAL;
      The_Name       :    out FileIO.String_Ptr)
   is
   begin
      if  The_Length <= 0  then 
         The_Name := null;
      else
         declare
            S : String (1..The_Length);         
            P : INT32;         
         begin
            P := The_Position;
            for  I in S'Range  loop
               S (I) := Current_Ch (P); 
               P     := P + 1;
            end loop;
            The_Name := new String'(S);
         end;
      end if;
   end Get_Name;


   --
   -- Returns exact character at position pos in source file
   --
   function Char_At (The_Position: in     INT32) return Character
   is
      C : Character;
   begin
      if  The_Position >= inputLen  then 
         return FileIO.EOF;
      end if;

      C := buf (ORDL (The_Position / LBlkSize))
               (ORDL ((The_Position mod LBlkSize)) + 1);

      if  C /= eof  then 
         return C;
      else 
         return FileIO.EOF;
      end if;
   end Char_At;


   function Up_Char_At (The_Position: in     INT32) return Character
   is
      C : Character;
   begin
      if  The_Position >= inputLen  then 
         return FileIO.EOF;
      end if;

      C := FileIO.Up_Case
            (buf (ORDL (The_Position / LBlkSize))
                 (ORDL (The_Position mod LBlkSize) + 1));

      if  C /= eof  then 
         return C ;
      else 
         return FileIO.EOF;
      end if;
   end Up_Char_At;


   --
   -- Reads and stores source file internally
   --
   procedure Reset
   is
      len   : INT32;
      I     : CARDINAL;
      read  : CARDINAL;
   begin -- assert: Source has been opened
      inputLen := FileIO.Length (Source); -- save Length of source

      I        := 0; 
      len      := inputLen;
      while  len > LBlkSize  loop
         buf (I) := new BufBlock;
         read    := BlkSize;
         FileIO.Read_Bytes (Source, buf (I).all, read);
         len := len - FileIO.INT (read); 
         I := I + 1;
      end loop;

      buf (I) := new BufBlock;
      read := ORDL (len); 
      FileIO.Read_Bytes (Source, buf (I).all, read);
      buf (I) (read) := EOF;

      curLine   := 1; 
      lineStart := -2;
      bp        := -1;
      oldEols   := 0; 
      apx       := 0;
      errors    := 0;

      Next_Ch;
   end Reset;


begin
   Current_Ch := Char_At'Access;
   Start (  0) := 15; Start (  1) := 16; Start (  2) := 16; Start (  3) := 16; 
   Start (  4) := 16; Start (  5) := 16; Start (  6) := 16; Start (  7) := 16; 
   Start (  8) := 16; Start (  9) := 16; Start ( 10) := 16; Start ( 11) := 16; 
   Start ( 12) := 16; Start ( 13) := 16; Start ( 14) := 16; Start ( 15) := 16; 
   Start ( 16) := 16; Start ( 17) := 16; Start ( 18) := 16; Start ( 19) := 16; 
   Start ( 20) := 16; Start ( 21) := 16; Start ( 22) := 16; Start ( 23) := 16; 
   Start ( 24) := 16; Start ( 25) := 16; Start ( 26) := 16; Start ( 27) := 16; 
   Start ( 28) := 16; Start ( 29) := 16; Start ( 30) := 16; Start ( 31) := 16; 
   Start ( 32) := 16; Start ( 33) := 16; Start ( 34) :=  3; Start ( 35) := 16; 
   Start ( 36) := 16; Start ( 37) := 16; Start ( 38) := 16; Start ( 39) := 16; 
   Start ( 40) := 16; Start ( 41) := 16; Start ( 42) :=  8; Start ( 43) := 16; 
   Start ( 44) := 14; Start ( 45) :=  6; Start ( 46) := 16; Start ( 47) := 16; 
   Start ( 48) :=  2; Start ( 49) :=  2; Start ( 50) :=  2; Start ( 51) :=  2; 
   Start ( 52) :=  2; Start ( 53) :=  2; Start ( 54) :=  2; Start ( 55) :=  2; 
   Start ( 56) :=  2; Start ( 57) :=  2; Start ( 58) := 16; Start ( 59) :=  5; 
   Start ( 60) := 12; Start ( 61) :=  9; Start ( 62) := 13; Start ( 63) := 16; 
   Start ( 64) := 16; Start ( 65) :=  1; Start ( 66) :=  1; Start ( 67) :=  1; 
   Start ( 68) :=  1; Start ( 69) :=  1; Start ( 70) :=  1; Start ( 71) :=  1; 
   Start ( 72) :=  1; Start ( 73) :=  1; Start ( 74) :=  1; Start ( 75) :=  1; 
   Start ( 76) :=  1; Start ( 77) :=  1; Start ( 78) :=  1; Start ( 79) :=  1; 
   Start ( 80) :=  1; Start ( 81) :=  1; Start ( 82) :=  1; Start ( 83) :=  1; 
   Start ( 84) :=  1; Start ( 85) :=  1; Start ( 86) :=  1; Start ( 87) :=  1; 
   Start ( 88) :=  1; Start ( 89) :=  1; Start ( 90) :=  1; Start ( 91) := 16; 
   Start ( 92) := 16; Start ( 93) := 16; Start ( 94) := 11; Start ( 95) :=  1; 
   Start ( 96) := 16; Start ( 97) :=  1; Start ( 98) :=  1; Start ( 99) :=  1; 
   Start (100) :=  1; Start (101) :=  1; Start (102) :=  1; Start (103) :=  1; 
   Start (104) :=  1; Start (105) :=  1; Start (106) :=  1; Start (107) :=  1; 
   Start (108) :=  1; Start (109) :=  1; Start (110) :=  1; Start (111) :=  1; 
   Start (112) :=  1; Start (113) :=  1; Start (114) :=  1; Start (115) :=  1; 
   Start (116) :=  1; Start (117) :=  1; Start (118) :=  1; Start (119) :=  1; 
   Start (120) :=  1; Start (121) :=  1; Start (122) :=  1; Start (123) := 16; 
   Start (124) := 16; Start (125) := 16; Start (126) := 10; Start (127) := 16; 
   Start (128) := 16; Start (129) := 16; Start (130) := 16; Start (131) := 16; 
   Start (132) := 16; Start (133) := 16; Start (134) := 16; Start (135) := 16; 
   Start (136) := 16; Start (137) := 16; Start (138) := 16; Start (139) := 16; 
   Start (140) := 16; Start (141) := 16; Start (142) := 16; Start (143) := 16; 
   Start (144) := 16; Start (145) := 16; Start (146) := 16; Start (147) := 16; 
   Start (148) := 16; Start (149) := 16; Start (150) := 16; Start (151) := 16; 
   Start (152) := 16; Start (153) := 16; Start (154) := 16; Start (155) := 16; 
   Start (156) := 16; Start (157) := 16; Start (158) := 16; Start (159) := 16; 
   Start (160) := 16; Start (161) := 16; Start (162) := 16; Start (163) := 16; 
   Start (164) := 16; Start (165) := 16; Start (166) := 16; Start (167) := 16; 
   Start (168) := 16; Start (169) := 16; Start (170) := 16; Start (171) := 16; 
   Start (172) := 16; Start (173) := 16; Start (174) := 16; Start (175) := 16; 
   Start (176) := 16; Start (177) := 16; Start (178) := 16; Start (179) := 16; 
   Start (180) := 16; Start (181) := 16; Start (182) := 16; Start (183) := 16; 
   Start (184) := 16; Start (185) := 16; Start (186) := 16; Start (187) := 16; 
   Start (188) := 16; Start (189) := 16; Start (190) := 16; Start (191) := 16; 
   Start (192) := 16; Start (193) := 16; Start (194) := 16; Start (195) := 16; 
   Start (196) := 16; Start (197) := 16; Start (198) := 16; Start (199) := 16; 
   Start (200) := 16; Start (201) := 16; Start (202) := 16; Start (203) := 16; 
   Start (204) := 16; Start (205) := 16; Start (206) := 16; Start (207) := 16; 
   Start (208) := 16; Start (209) := 16; Start (210) := 16; Start (211) := 16; 
   Start (212) := 16; Start (213) := 16; Start (214) := 16; Start (215) := 16; 
   Start (216) := 16; Start (217) := 16; Start (218) := 16; Start (219) := 16; 
   Start (220) := 16; Start (221) := 16; Start (222) := 16; Start (223) := 16; 
   Start (224) := 16; Start (225) := 16; Start (226) := 16; Start (227) := 16; 
   Start (228) := 16; Start (229) := 16; Start (230) := 16; Start (231) := 16; 
   Start (232) := 16; Start (233) := 16; Start (234) := 16; Start (235) := 16; 
   Start (236) := 16; Start (237) := 16; Start (238) := 16; Start (239) := 16; 
   Start (240) := 16; Start (241) := 16; Start (242) := 16; Start (243) := 16; 
   Start (244) := 16; Start (245) := 16; Start (246) := 16; Start (247) := 16; 
   Start (248) := 16; Start (249) := 16; Start (250) := 16; Start (251) := 16; 
   Start (252) := 16; Start (253) := 16; Start (254) := 16; Start (255) := 16; 

   Error    := Err'Access; 
   LBlkSize := FileIO.INT (BlkSize);
   lastCh   := EOF;
end RulesS;





